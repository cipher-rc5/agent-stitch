This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-24T20:55:43.570Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cache/
  index.ts
chat/
  index.ts
clients/
  index.ts
config/
  index.ts
database/
  index.ts
character.ts
index.ts

================================================================
Files
================================================================

================
File: cache/index.ts
================
// src/cache/index.ts

import { CacheManager, Character, DbCacheAdapter, IDatabaseCacheAdapter } from '@elizaos/core';

export function initializeDbCache(character: Character, db: IDatabaseCacheAdapter) {
  const cache = new CacheManager(new DbCacheAdapter(db, character.id));
  return cache;
}

================
File: chat/index.ts
================
// src/chat/index.ts

import { settings } from '@elizaos/core';
import readline from 'readline';

const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

rl.on('SIGINT', () => {
  rl.close();
  process.exit(0);
});

async function handleUserInput(input: string, agentId: any) {
  if (input.toLowerCase() === 'exit') {
    rl.close();
    process.exit(0);
  }

  try {
    const serverPort = parseInt(settings.SERVER_PORT || '3000');

    const response = await fetch(`http://localhost:${serverPort}/${agentId}/message`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: input, userId: 'user', userName: 'User' })
    });

    const data = await response.json();
    data.forEach((message: { text: any }) => console.log(`${'Agent'}: ${message.text}`));
  } catch (error) {
    console.error('Error fetching response:', error);
  }
}

export function startChat(characters: { name: string }[]) {
  function chat() {
    const agentId = characters[0].name ?? 'Agent';
    rl.question('You: ', async (input) => {
      await handleUserInput(input, agentId);
      if (input.toLowerCase() !== 'exit') {
        chat(); // Loop back to ask another question
      }
    });
  }

  return chat;
}

================
File: clients/index.ts
================
// src/clients/index.ts

import { AutoClientInterface } from '@elizaos/client-auto';
import { DiscordClientInterface } from '@elizaos/client-discord';
import { Character, IAgentRuntime } from '@elizaos/core';

export async function initializeClients(character: Character, runtime: IAgentRuntime) {
  const clients = [];
  const clientTypes = character.clients?.map((str) => str.toLowerCase()) || [];

  if (clientTypes.includes('auto')) {
    const autoClient = await AutoClientInterface.start(runtime);
    if (autoClient) clients.push(autoClient);
  }

  if (clientTypes.includes('discord')) {
    clients.push(await DiscordClientInterface.start(runtime));
  }

  if (character.plugins?.length > 0) {
    for (const plugin of character.plugins) {
      if (plugin.clients) {
        for (const client of plugin.clients) {
          clients.push(await client.start(runtime));
        }
      }
    }
  }

  return clients;
}

================
File: config/index.ts
================
// src/config/index.ts

import { Character, ModelProviderName, settings, validateCharacterConfig } from '@elizaos/core';
import fs from 'fs';
import path from 'path';
import yargs from 'yargs';

export function parseArguments(): { character?: string, characters?: string } {
  try {
    return yargs(process.argv.slice(2)).option('character', {
      type: 'string',
      description: 'Path to the character JSON file'
    }).option('characters', { type: 'string', description: 'Comma separated list of paths to character JSON files' })
      .parseSync();
  } catch (error) {
    console.error('Error parsing arguments:', error);
    return {};
  }
}

export async function loadCharacters(charactersArg: string): Promise<Character[]> {
  let characterPaths = charactersArg?.split(',').map((filePath) => {
    if (path.basename(filePath) === filePath) {
      filePath = '../characters/' + filePath;
    }
    return path.resolve(process.cwd(), filePath.trim());
  });

  const loadedCharacters = [];

  if (characterPaths?.length > 0) {
    for (const path of characterPaths) {
      try {
        const character = JSON.parse(fs.readFileSync(path, 'utf8'));

        validateCharacterConfig(character);

        loadedCharacters.push(character);
      } catch (e) {
        console.error(`Error loading character from ${path}: ${e}`);
        process.exit(1);
      }
    }
  }

  return loadedCharacters;
}

export function getTokenForProvider(provider: ModelProviderName, character: Character) {
  switch (provider) {
    case ModelProviderName.OPENAI:
      return (character.settings?.secrets?.OPENAI_API_KEY || settings.OPENAI_API_KEY);
    case ModelProviderName.ANTHROPIC:
      return (character.settings?.secrets?.ANTHROPIC_API_KEY ||
        character.settings?.secrets?.CLAUDE_API_KEY ||
        settings.ANTHROPIC_API_KEY ||
        settings.CLAUDE_API_KEY);
    case ModelProviderName.OPENROUTER:
      return (character.settings?.secrets?.OPENROUTER || settings.OPENROUTER_API_KEY);
    case ModelProviderName.GROK:
      return character.settings?.secrets?.GROK_API_KEY || settings.GROK_API_KEY;
    case ModelProviderName.HEURIST:
      return (character.settings?.secrets?.HEURIST_API_KEY || settings.HEURIST_API_KEY);
    case ModelProviderName.GROQ:
      return character.settings?.secrets?.GROQ_API_KEY || settings.GROQ_API_KEY;
  }
}

================
File: database/index.ts
================
// src/database/index.ts

import { PostgresDatabaseAdapter } from '@elizaos/adapter-postgres';
import { SqliteDatabaseAdapter } from '@elizaos/adapter-sqlite';
import Database from 'better-sqlite3';
import path from 'path';

export function initializeDatabase(dataDir: string) {
  if (process.env.POSTGRES_URL) {
    const db = new PostgresDatabaseAdapter({ connectionString: process.env.POSTGRES_URL });
    return db;
  } else {
    const filePath = process.env.SQLITE_FILE ?? path.resolve(dataDir, 'db.sqlite');
    const db = new SqliteDatabaseAdapter(new Database(filePath));
    return db;
  }
}

================
File: character.ts
================
// src/character.ts

import { Character, Clients, ModelProviderName } from '@elizaos/core';

export const character: Character = {
  name: 'agent-stitch',
  plugins: [],
  clients: [Clients.DISCORD],
  modelProvider: ModelProviderName.OLLAMA,
  settings: {
    secrets: {
      'OLLAMA_SERVER_URL': 'http://localhost:11434',
      'OLLAMA_MODEL': 'llama2',
      'OLLAMA_EMBEDDING_MODEL': 'llama3.2'
    },
    voice: { model: 'en_US-male-playful' }
  },
  bio: ['Always ready to lend a helping hand to creators, gamers, and enthusiasts in the blockchain gaming space.'],
  lore: [
    'Dedicated to assisting gamers, developers, and creators, agent-stitch thrives on building connections and spreading knowledge.'
  ],
  knowledge: [
    'Crypto-native gaming ecosystems and their unique dynamics',
    'Building strong and inclusive gaming communities',
    'Classic and modern games loved by gamers across generations',
    'The technical and creative aspects of game development',
    'Blockchain technology and its role in revolutionizing gaming'
  ],
  style: {
    all: ['friendly', 'community-oriented', 'supportive'],
    chat: ['approachable', 'kind', 'encouraging'],
    post: ['informative', 'engaging', 'inclusive']
  },
  adjectives: ['friendly', 'helpful', 'kind', 'engaging', 'community-focused', 'knowledgeable'],
  messageExamples: [[{ user: 'agent-stitch', content: { text: '' } }, {
    user: 'User',
    content: { text: 'Can you tell me about the Adjutant programmatic WL?' }
  }, { user: 'agent-stitch', content: { text: '' } }], [{ user: 'agent-stitch', content: { text: '' } }, {
    user: 'User',
    content: { text: "That's great! Where can I learn more?" }
  }, {
    user: 'agent-stitch',
    content: { text: 'Check out our website or hop into the Discord community for all the latest updates!' }
  }]],
  postExamples: [],
  topics: [
    'Community building in gaming',
    'Blockchain technology in gaming',
    'Empowering creators and developers',
    'Classic and modern gaming cultures'
  ]
};

================
File: index.ts
================
// src/index.ts

import { DirectClient } from '@elizaos/client-direct';
import { AgentRuntime, type Character, elizaLogger, settings, stringToUuid } from '@elizaos/core';
import { bootstrapPlugin } from '@elizaos/plugin-bootstrap';
import { createNodePlugin } from '@elizaos/plugin-node';
import { solanaPlugin } from '@elizaos/plugin-solana';
import fs from 'fs';
import net from 'net';
import path from 'path';
import { fileURLToPath } from 'url';
import { initializeDbCache } from './cache/index.ts';
import { character } from './character.ts';
import { startChat } from './chat/index.ts';
import { initializeClients } from './clients/index.ts';
import { getTokenForProvider, loadCharacters, parseArguments } from './config/index.ts';
import { initializeDatabase } from './database/index.ts';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export const wait = (minTime: number = 1000, maxTime: number = 3000) => {
  const waitTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;
  return new Promise((resolve) => setTimeout(resolve, waitTime));
};

let nodePlugin: any | undefined;

export function createAgent(character: Character, db: any, cache: any, token: string) {
  elizaLogger.success(elizaLogger.successesTitle, 'Creating runtime for character', character.name);

  nodePlugin ??= createNodePlugin();

  return new AgentRuntime({
    databaseAdapter: db,
    token,
    modelProvider: character.modelProvider,
    evaluators: [],
    character,
    plugins: [bootstrapPlugin, nodePlugin, character.settings?.secrets?.WALLET_PUBLIC_KEY ? solanaPlugin : null].filter(
      Boolean
    ),
    providers: [],
    actions: [],
    services: [],
    managers: [],
    cacheManager: cache
  });
}

async function startAgent(character: Character, directClient: DirectClient) {
  try {
    character.id ??= stringToUuid(character.name);
    character.username ??= character.name;

    const token = getTokenForProvider(character.modelProvider, character);
    const dataDir = path.join(__dirname, '../data');

    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    const db = initializeDatabase(dataDir);

    await db.init();

    const cache = initializeDbCache(character, db);
    const runtime = createAgent(character, db, cache, token);

    await runtime.initialize();

    runtime.clients = await initializeClients(character, runtime);

    directClient.registerAgent(runtime);

    elizaLogger.debug(`Started ${character.name} as ${runtime.agentId}`);

    return runtime;
  } catch (error) {
    elizaLogger.error(`Error starting agent for character ${character.name}:`, error);
    console.error(error);
    throw error;
  }
}

const checkPortAvailable = (port: number): Promise<boolean> => {
  return new Promise((resolve) => {
    const server = net.createServer();

    server.once('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        resolve(false);
      }
    });

    server.once('listening', () => {
      server.close();
      resolve(true);
    });

    server.listen(port);
  });
};

const startAgents = async () => {
  const directClient = new DirectClient();
  let serverPort = parseInt(settings.SERVER_PORT || '3000');
  const args = parseArguments();

  let charactersArg = args.characters || args.character;
  let characters = [character];

  console.log('charactersArg', charactersArg);
  if (charactersArg) {
    characters = await loadCharacters(charactersArg);
  }
  console.log('characters', characters);
  try {
    for (const character of characters) {
      await startAgent(character, directClient as DirectClient);
    }
  } catch (error) {
    elizaLogger.error('Error starting agents:', error);
  }

  while (!(await checkPortAvailable(serverPort))) {
    elizaLogger.warn(`Port ${serverPort} is in use, trying ${serverPort + 1}`);
    serverPort++;
  }

  directClient.startAgent = async (character: Character) => {
    return startAgent(character, directClient);
  };

  directClient.start(serverPort);

  if (serverPort !== parseInt(settings.SERVER_PORT || '3000')) {
    elizaLogger.log(`Server started on alternate port ${serverPort}`);
  }

  const isDaemonProcess = process.env.DAEMON_PROCESS === 'true';
  if (!isDaemonProcess) {
    elizaLogger.log("Chat started. Type 'exit' to quit.");
    const chat = startChat(characters);
    chat();
  }
};

startAgents().catch((error) => {
  elizaLogger.error('Unhandled error in startAgents:', error);
  process.exit(1);
});
